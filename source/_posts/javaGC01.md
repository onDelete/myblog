---
title: java中的垃圾回收与内存分配
date: 2016-10-15 15:44:08
tags: GC
categories: JavaSE
---
java中GC涉及到java内存的分配与回收管理。虽然jvm承诺自动回收java的内存，但是java依然会出现内存的泄漏，也就是一些无用的内存无法回收的问题。由于java程序员无法直接控制jvm回收无用内存，即便是调用`System.gc()`，也只是建议jvm实施垃圾回收，但是具体的回收过程还是无法立即实现。由于盏内存随着方法的结束被回收，而且栈内存大小一般在运行期间就已经确定，所以这里涉及到的主要是堆内存的回收与分配。
<!--more-->
### 回收机制
1.当某个对象处于不可达的状态，也就是没有任何的引用指向该对象，便会准备回收该对象的内存；
2.jvm要清理、分配内存，整理回收过程中产生的内存碎片。

### 垃圾回收的基本算法
java虚拟机在执行垃圾回收时，会判断每个对象所处的状态，依据其存在时间的长短，将其分为Young、Old、Permanent，对不同代的对象执行的回收算法也不相一致。
1.绝大多数的对象不会被长时间的引用，这些对象在年轻代就被回收。针对年轻代的对象，虚拟机会开辟一个Eden区和两个Survivor区，其中Eden区存放着绝大多数的年轻对象，有些较大的年轻对象则直接存放到Old代的内存区，而两个Survivor区中有一个区存放对象,这个区中的年轻代的对象至少经历过一次回收，另一个区是空的。对于年轻代的对象采用的是复制算法（copying），具体来讲就是当年轻代所占用的空间快要占满时，判断年轻代中在Eden和Survivor区中可达的对象，将其存放到另一个空的Survivor区中，然后对Eden和Survivor区中的空间进行清理，将它们的内存回收作为新的Eden和Survivor区。默认的Eden和Survivor区的大小的比例为`32:1`。
2.对于年轻代中多次回收任然可达的对象，将被存入Old代内存区。Old代需要的空间更大，并且由于Old代的对象一般存活的时间很长，不需要多次执行回收，所以其一般采用标记压缩（mark-sweep-compact）的回收算法。具体来讲就是，当这部分空间快要占满时，将Old代的可达对像逐个进行标记，将不可达的对象回收，然后将可达的对象空间进行压缩，等有新的对象存入时，存放在空间的尾端。
3.Permanent代空间用于装载Class、Method的信息，默认是64M，通常不会执行回收，除非程序结束，随类的创建而加载。

### 垃圾回收的相关选项

```
-Xmx: 堆内存最大容量
-Xms: 堆初始容量
-XX:MinHeapFreeRatio=size 堆内存最小空闲百分比
-XX:MaxHeapFreeRatio=size 堆内存最大空闲百分比
-XX:NewRatio=size　年轻代和年老代内存空间比
-XX:NewSize=size　年轻代内存默认容量
-XX:SurvivorRatio=size　Eden和Survivor空间的比例
-XX:MaxNewSize=size　年轻代最大容量
-XX:PermSize=size　持久代默认容量
-XX:MaxPermSize=size　持久代最大容量
```

### 回收器
1.串行回收器(Serial Collector)开辟一个单线程来进行内存的回收（单核CPU）,而并行回收器开辟多个线程进行回收(多核CPU),并行回收在运行是消耗更大，但是效率更高。在对年老代对象进行的是串行回收，而年轻代的回收则取决于具体服务器的核心数目。
配置使用：
```
-XX:+Use SerialGC 使用串行GC回收器
-XX:+Use ParallelGC　使用并行GC回收器
-XX:ParallelGCThreads=size　配置并行GC回收器线程数目
```
2.java5.0之后引入并行压缩回收器，年轻代对象处理方式不变，将Old代对象分成了密集区与非密集区分别处理。
配置使用：
```
-XX:+Use ParallelOldGC　使用并行GC
-XX:ParallelOldGCThreads=size　配置并行GC线程数目
```
3.并发标识清理（Mark-Sweep CMS）
并行处理GC不会出现程序暂停，而并发处理会引起程序短暂的暂停。由于CMS回收对象不压缩，所以其处理的空间不连续，间接地导致内存分配的效率下降。

### 内存管理小技巧
1.使用String和基本类的包装类时使用直接量，尽量不使用new操作符创建对象；
2.使用StringBuilder和StringBuffer来操作字符串的连接操作；
3.尽早释放无用的对象（obj=null）；
4.尽量少用静态变量；
5.避免循环创建对象；
6.缓存经常使用的对象，可以利用数据连接池、HashMap等；
7.尽量不使用finalize，这样会增加GC的负担；
8.可以使用软引用；